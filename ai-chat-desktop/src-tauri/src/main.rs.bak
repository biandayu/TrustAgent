#[cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

mod agent;

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs::{self, File};
use std::path::PathBuf;
use std::sync::{Arc, Mutex};
use tauri::{App, Manager, State, Window};
use tracing::{error, info, warn};
use uuid::Uuid;
use rmcp::{Peer, RoleClient};

// --- Configuration Structures ---

#[derive(Debug, Serialize, Deserialize, Clone, Default)]
struct AppConfig {
    openai: OpenAIParams,
    #[serde(rename = "mcpServers")]
    mcp_servers: HashMap<String, McpServerProcessConfig>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
struct McpServerProcessConfig {
    command: String,
    args: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
struct OpenAIParams {
    api_key: String,
    base_url: String,
    model: String,
}

impl Default for OpenAIParams {
    fn default() -> Self {
        Self {
            api_key: "".to_string(),
            base_url: "https://api.openai.com/v1".to_string(),
            model: "gpt-4-turbo".to_string(),
        }
    }
}

// --- Chat Structures ---
#[derive(Debug, Clone, Serialize, Deserialize)]
struct ChatMessage {
    role: String,
    content: String,
    timestamp: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct ChatSession {
    id: String,
    title: String,
    messages: Vec<ChatMessage>,
    created_at: u64,
    updated_at: u64,
}

impl ChatSession {
    fn new(id: String, title: String) -> Self {
        let now = now_ts();
        Self {
            id,
            title,
            messages: Vec::new(),
            created_at: now,
            updated_at: now,
        }
    }
}

fn now_ts() -> u64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs()
}

// --- Application State ---

#[derive(Debug, Serialize, Clone)]
struct McpServerInfo {
    name: String,
    status: String, // "running" or "stopped"
}

struct AppState {
    config: Mutex<AppConfig>,
    sessions: Mutex<HashMap<String, ChatSession>>,
    current_session_id: Mutex<Option<String>>,
    tool_states: Mutex<HashMap<String, bool>>, // Key: "{server_name}/{tool_name}"
    mcp_tools: Mutex<HashMap<String, Vec<String>>>, // 工具名列表
    mcp_clients: Mutex<HashMap<String, Arc<rmcp::service::RunningService<rmcp::service::RoleClient, ()>>>>, // Active MCP clients
}

// --- Filesystem and Config Logic ---
fn get_app_base_dir() -> PathBuf {
    dirs_next::config_dir()
        .expect("Failed to find config directory")
        .join("TrustAgent")
}

fn get_app_data_dir() -> PathBuf {
    let data_dir = get_app_base_dir().join("data");
    if !data_dir.exists() {
        fs::create_dir_all(&data_dir).expect("Failed to create app data directory");
    }
    data_dir
}

fn get_app_config_path() -> PathBuf {
    let config_dir = get_app_base_dir().join("configuration");
    if !config_dir.exists() {
        fs::create_dir_all(&config_dir).expect("Failed to create app config directory");
    }
    config_dir.join("settings.json")
}

fn get_app_log_dir() -> PathBuf {
    let log_dir = get_app_base_dir().join("logs");
    if !log_dir.exists() {
        fs::create_dir_all(&log_dir).expect("Failed to create app log directory");
    }
    log_dir
}

fn save_session_to_file(session: &ChatSession) -> Result<(), String> {
    let dir = get_app_data_dir().join(".chats");
    if !dir.exists() {
        fs::create_dir_all(&dir).ok();
    }
    let path = dir.join(format!("{}.json", session.id));
    let content = serde_json::to_string_pretty(session).map_err(|e| e.to_string())?;
    fs::write(path, content).map_err(|e| e.to_string())?;
    Ok(())
}

fn delete_session_file(session_id: &str) -> Result<(), String> {
    let dir = get_app_data_dir().join(".chats");
    let path = dir.join(format!("{}.json", session_id));
    if path.exists() {
        fs::remove_file(path).map_err(|e| e.to_string())?;
    }
    Ok(())
}

fn load_sessions_from_files() -> HashMap<String, ChatSession> {
    let dir = get_app_data_dir().join(".chats");
    if !dir.exists() {
        fs::create_dir_all(&dir).ok();
    }
    let mut map = HashMap::new();
    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            if let Ok(content) = fs::read_to_string(entry.path()) {
                if let Ok(session) = serde_json::from_str::<ChatSession>(&content) {
                    map.insert(session.id.clone(), session);
                }
            }
        }
    }
    map
}

fn load_or_initialize_config() -> AppConfig {
    let config_path = get_app_config_path();
    if config_path.exists() {
        let content = fs::read_to_string(&config_path).unwrap_or_default();
        serde_json::from_str(&content).unwrap_or_else(|e| {
            warn!("Failed to parse config file, using default. Error: {}", e);
            let default_config = AppConfig::default();
            fs::write(
                &config_path,
                serde_json::to_string_pretty(&default_config).unwrap(),
            )
            .ok();
            default_config
        })
    } else {
        info!("No config file found, creating a default one.");
        let default_config = AppConfig::default();
        fs::write(
            &config_path,
            serde_json::to_string_pretty(&default_config).unwrap(),
        )
        .expect("Failed to write default config file");
        default_config
    }
}

fn generate_session_title(messages: &[ChatMessage]) -> String {
    messages
        .iter()
        .find(|m| m.role == "user")
        .map(|m| {
            let mut t = m.content.trim().to_string();
            if t.len() > 20 {
                t.truncate(20);
                t.push_str("...");
            }
            t
        })
        .unwrap_or_else(|| "New Chat".to_string())
}

// --- MCP Logic ---

async fn _start_mcp_server_logic(
    server_name: String,
    state: Arc<AppState>,
    window: Window,
) -> Result<(), String> {
    info!(server_name = %server_name, "Attempting to start MCP server");
    let config = state.config.lock().unwrap().clone();
    let server_config = config
        .mcp_servers
        .get(&server_name)
        .cloned()
        .ok_or_else(|| "Server config not found".to_string())?;

    use rmcp::{ServiceExt, transport::TokioChildProcess};
    use rmcp::model::PaginatedRequestParam;
    use std::process::Stdio;
    use tokio::process::Command;

    let log_dir = get_app_log_dir();
    let log_path = log_dir.join(format!("mcp-{}.log", server_name));
    
    // Create log file for stderr only
    use std::io::Write;
    let mut stderr_log_file = File::create(&log_path).map_err(|e| format!("Failed to create MCP log file: {} (Path: {:?})", e, log_path))?;
    stderr_log_file.flush().map_err(|e| format!("Failed to flush log file: {} (Path: {:?})", e, log_path))?;

    let mut cmd = Command::new(&server_config.command);
    cmd.args(&server_config.args);
    cmd.stdin(Stdio::piped())
       .stdout(Stdio::piped())  // Keep stdout for MCP protocol communication
       .stderr(stderr_log_file); // Only redirect stderr to log file

    // Set the working directory for the child process to be the app's base directory.
    // This is crucial for node-based servers that might resolve packages or files
    // relative to the current working directory.
    let working_dir = get_app_base_dir();
    info!(server_name = %server_name, "Setting MCP server working directory to: {:?}", working_dir);
    cmd.current_dir(&working_dir);

    let current_path = std::env::var("PATH").map_err(|e| format!("Failed to get PATH environment variable: {}", e))?;
    cmd.env("PATH", &current_path);

    // --- Enhanced Debug Logging for ALL servers ---
    info!(server_name = %server_name, "=== MCP SERVER STARTUP DEBUG INFO ===");
    info!(server_name = %server_name, "Command: {}", server_config.command);
    info!(server_name = %server_name, "Args: {:?}", server_config.args);
    info!(server_name = %server_name, "Current working directory: {:?}", std::env::current_dir());
    info!(server_name = %server_name, "Server working directory (set for child): {:?}", working_dir);
    info!(server_name = %server_name, "PATH environment: {}", current_path);
    info!(server_name = %server_name, "Log file path: {:?}", log_path);
    
    // 构建完整的命令字符串用于调试
    let full_command = format!("{} {}", server_config.command, server_config.args.join(" "));
    info!(server_name = %server_name, "Full command string: {}", full_command);
    
    // 检查命令文件是否存在
    let command_path = std::path::Path::new(&server_config.command);
    if command_path.is_absolute() {
        info!(server_name = %server_name, "Command path exists: {}, is_file: {}, is_executable (Windows): {}", command_path.exists(), command_path.is_file(), command_path.exists()); // Windows check
    } else {
        // 如果是相对路径，尝试在 PATH 中查找
        let path_dirs: Vec<&str> = current_path.split(';').collect();
        info!(server_name = %server_name, "Searching for command in PATH directories: {:?}", path_dirs);
        
        let mut found = false;
        for dir in &path_dirs {
            let full_path = std::path::Path::new(dir).join(&server_config.command);
            if full_path.exists() {
                info!(server_name = %server_name, "Found command at: {:?}", full_path);
                found = true;
                break;
            }
        }
        if !found {
             warn!(server_name = %server_name, "Command '{}' not found in PATH", server_config.command);
        }
    }
    
    // 对于非 Windows 系统，可以尝试 --version 或 --help
    // 在 Windows 上，我们主要依赖 PATH 查找和文件存在性检查
    // 但我们仍然可以尝试运行带有 --help 的命令来测试它是否能启动
    info!(server_name = %server_name, "Testing full command with --help (this is a test run, not the actual server start)");
    let mut test_cmd = std::process::Command::new(&server_config.command);
    test_cmd.args(&server_config.args);
    test_cmd.arg("--help"); // 添加一个无害的参数来测试命令是否能启动
    test_cmd.current_dir(&working_dir); // Use the same working dir for test
    test_cmd.env("PATH", &current_path); // Use the same PATH for test
    match test_cmd.output() {
        Ok(output) => {
            let stdout_str = String::from_utf8_lossy(&output.stdout);
            let stderr_str = String::from_utf8_lossy(&output.stderr);
            info!(server_name = %server_name, "Full command test successful. Output length (stdout/stderr): {}/{}, Exit code: {:?}", stdout_str.len(), stderr_str.len(), output.status.code());
            if !stdout_str.trim().is_empty() {
                 info!(server_name = %server_name, "Test run stdout (first 500 chars): {}", &stdout_str[..std::cmp::min(500, stdout_str.len())]);
            }
            if !stderr_str.trim().is_empty() {
                 info!(server_name = %server_name, "Test run stderr (first 500 chars): {}", &stderr_str[..std::cmp::min(500, stderr_str.len())]);
            }
        }
        Err(e) => {
            warn!(server_name = %server_name, "Full command test failed (this might be ok if --help isn't supported): {}", e);
        }
    }
    
    info!(server_name = %server_name, "=== END MCP SERVER STARTUP DEBUG INFO ===");

    info!(server_name = %server_name, command = %server_config.command, args = ?server_config.args, "Starting MCP server process");

    let start_time = std::time::Instant::now();
    // Create MCP client using the ServiceExt trait with TokioChildProcess
    let child_proc = TokioChildProcess::new(cmd).map_err(|e| {
        let duration = start_time.elapsed();
        error!(server_name = %server_name, "Failed to wrap child process after {:?}. Error details: {}", duration, e);
        error!(server_name = %server_name, "Command: {}", server_config.command);
        error!(server_name = %server_name, "Args: {:?}", server_config.args);
        error!(server_name = %server_name, "Current PATH: {}", current_path);
        
        // Try to read the last part of the stderr log file
        let log_tail = read_last_lines_of_file(&log_path, 20).unwrap_or_else(|_| "Failed to read log file".to_string());
        if !log_tail.trim().is_empty() {
            error!(server_name = %server_name, "Last lines of stderr log:
{}", log_tail);
        } else {
            error!(server_name = %server_name, "Stderr log file is empty or could not be read.");
        }
        
        format!("Failed to wrap child process for '{}': {}. Log tail: {}", server_name, e, log_tail)
    })?;

    let wrap_duration = start_time.elapsed();
    info!(server_name = %server_name, "Child process wrapped successfully in {:?}", wrap_duration);

    // Add a longer delay to allow the child process to fully initialize
    // Increase the delay slightly and log before/after
    info!(server_name = %server_name, "Waiting for child process to initialize...");
    let sleep_start = std::time::Instant::now();
    tokio::time::sleep(tokio::time::Duration::from_millis(2000)).await; // Increased to 2 seconds
    let sleep_duration = sleep_start.elapsed();
    info!(server_name = %server_name, "Initialization wait completed in {:?}", sleep_duration);

    info!(server_name = %server_name, "Attempting to establish MCP connection");
    let connect_start = std::time::Instant::now();

    // Create MCP client using the ServiceExt trait
    // This returns a RunningService which manages the connection lifecycle
    let running_service = ().serve(child_proc).await.map_err(|e| {
        let connect_duration = connect_start.elapsed();
        error!(server_name = %server_name, "MCP connection failed after {:?}: {}", connect_duration, e);
        
        // Try to read the last part of the stderr log file again
        let log_tail = read_last_lines_of_file(&log_path, 20).unwrap_or_else(|_| "Failed to read log file".to_string());
        if !log_tail.trim().is_empty() {
            error!(server_name = %server_name, \"Last lines of stderr log:\n{}\", log_tail);
        } else {
            error!(server_name = %server_name, \"Stderr log file is empty or could not be read.\");
        }
        
        format!(\"MCP connection to '{}' failed: {}. Log tail: {}\", server_name, e, log_tail)
    })?;

    let connect_duration = connect_start.elapsed();
    info!(server_name = %server_name, \"MCP connection established in {:?}\", connect_duration);
    
    // Store the RunningService in the state for later use by the agent
    // The RunningService itself is moved into the HashMap. 
    // The Arc<RunningService> stored in the HashMap will keep it alive.
    state
        .mcp_clients
        .lock()
        .unwrap()
        .insert(server_name.clone(), Arc::new(running_service));

    // --- Post-connection checks ---
    info!(server_name = %server_name, \"Performing post-connection checks...\");
    
    // 1. List tools to verify the connection is alive and functional
    // We need to get the Peer from the RunningService to call list_tools
    info!(server_name = %server_name, \"Listing tools to verify connection...\");
    let tools_start = std::time::Instant::now();
    // Use `running_service.as_ref()` to get `&Peer<RoleClient>`
    let tools_result = running_service.as_ref() // Get &Peer<RoleClient> from RunningService
        .list_tools(None::<PaginatedRequestParam>)
        .await
        .map_err(|e| {
            let tools_duration = tools_start.elapsed();
            error!(server_name = %server_name, \"Failed to list tools after {:?}: {}\", tools_duration, e);
            
            // Try to read the last part of the stderr log file again
            let log_tail = read_last_lines_of_file(&log_path, 20).unwrap_or_else(|_| \"Failed to read log file\".to_string());
            if !log_tail.trim().is_empty() {
                error!(server_name = %server_name, \"Last lines of stderr log:\n{}\", log_tail);
            } else {
                error!(server_name = %server_name, \"Stderr log file is empty or could not be read.\");
            }
            
            format!(\"Failed to list tools for '{}': {}. Log tail: {}\", server_name, e, log_tail)
        })?
    let tools_duration = tools_start.elapsed();
     
    let tool_names = tools_result
        .tools
        .iter()
        .map(|t| t.name.to_string())
        .collect::<Vec<String>>();

    info!(server_name = %server_name, tools = ?tool_names, "MCP server started successfully and tools discovered in {:?}", tools_duration);

    state
        .mcp_tools
        .lock()
        .unwrap()
        .insert(server_name.clone(), tool_names);

    // Notify frontend of the change
    window
        .emit("mcp_server_status_changed", ())
        .map_err(|e| e.to_string())?;

    Ok(())
}

// --- Tauri MCP Commands ---

#[tauri::command]
fn get_mcp_servers(state: State<'_, Arc<AppState>>) -> Result<Vec<McpServerInfo>, String> {
    let config = state.config.lock().unwrap();
    let servers_info = config
        .mcp_servers
        .keys()
        .map(|name| McpServerInfo {
            name: name.clone(),
            status: if state.mcp_tools.lock().unwrap().contains_key(name) {
                "running".to_string()
            } else {
                "stopped".to_string()
            },
        })
        .collect();
    Ok(servers_info)
}

#[tauri::command]
async fn start_mcp_server(
    server_name: String,
    state: State<'_, Arc<AppState>>,
    window: Window,
) -> Result<(), String> {
    _start_mcp_server_logic(server_name, state.inner().clone(), window).await
}

#[tauri::command]
async fn stop_mcp_server(
    server_name: String,
    state: State<'_, Arc<AppState>>,
    window: Window,
) -> Result<(), String> {
    info!(server_name = %server_name, "Stopping MCP server");
    state.mcp_tools.lock().unwrap().remove(&server_name);
    // Here you would also kill the process if you were managing it.
    // For now, we just remove it from the list of active tool providers.
    warn!(server_name = %server_name, "Process handle not stored, cannot kill process. Only removing from active list.");
    window
        .emit("mcp_server_status_changed", ())
        .map_err(|e| e.to_string())?;
    Ok(())
}

#[tauri::command]
fn get_discovered_tools(
    server_name: String,
    state: State<'_, Arc<AppState>>,
) -> Result<Vec<String>, String> {
    let tools = state.mcp_tools.lock().unwrap();
    Ok(tools.get(&server_name).cloned().unwrap_or_default())
}

// --- Agent Commands ---
#[tauri::command]
async fn run_agent_task(
    message: String,
    state: State<'_, Arc<AppState>>,
) -> Result<String, String> {
    info!(%message, "Running agent task");

    // 1. Collect available tools from the state
    let available_tools: Vec<agent::Tool> = {
        let mcp_tools_guard = state.mcp_tools.lock().unwrap();
        mcp_tools_guard
            .iter()
            .flat_map(|(server_name, tools)| {
                tools.iter().map(move |tool_name| agent::Tool {
                    server_name: server_name.clone(),
                    tool_name: tool_name.clone(),
                    // TODO: Eventually, we'll want to get tool descriptions from the MCP server
                    description: format!("A tool named '{}' from server '{}'", tool_name, server_name),
                })
            })
            .collect()
    }; // The lock guard is dropped here, before the .await point

    // 2. Create an agent instance and run the task
    let agent = agent::Agent::new();
    let result = agent
        .run_task(message, available_tools, state.inner().clone())
        .await;

    // TODO: Handle saving user and assistant messages to the session

    result
}

// --- Tauri Session Commands ---

#[tauri::command]
fn rename_session(
    id: String,
    new_title: String,
    state: State<'_, Arc<AppState>>,
) -> Result<(), String> {
    let mut sessions = state.sessions.lock().unwrap();
    if let Some(session) = sessions.get_mut(&id) {
        session.title = new_title;
        session.updated_at = now_ts();
        save_session_to_file(session)?;
    }
    Ok(())
}

#[tauri::command]
fn delete_session(id: String, state: State<'_, Arc<AppState>>) -> Result<(), String> {
    let mut sessions = state.sessions.lock().unwrap();
    if sessions.remove(&id).is_some() {
        delete_session_file(&id)?;
    }
    Ok(())
}

#[tauri::command]
fn open_config_file() -> Result<(), String> {
    let path = get_app_config_path();
    opener::open(&path).map_err(|e| format!("Failed to open config file: {}", e))
}

#[tauri::command]
async fn get_all_sessions(state: State<'_, Arc<AppState>>) -> Result<Vec<ChatSession>, String> {
    let sessions = state.sessions.lock().unwrap();
    let mut list: Vec<_> = sessions.values().cloned().collect();
    list.sort_by_key(|s| std::cmp::Reverse(s.updated_at));
    Ok(list)
}

#[tauri::command]
async fn finalize_and_new_chat(state: State<'_, Arc<AppState>>) -> Result<String, String> {
    let mut sessions = state.sessions.lock().unwrap();
    let mut current_id_guard = state.current_session_id.lock().unwrap();

    if let Some(old_id) = current_id_guard.clone() {
        let is_empty = sessions
            .get(&old_id)
            .map_or(true, |s| s.messages.is_empty());

        if is_empty {
            sessions.remove(&old_id);
        } else {
            if let Some(session) = sessions.get_mut(&old_id) {
                if session.title == "New Chat" {
                    session.title = generate_session_title(&session.messages);
                }
                session.updated_at = now_ts();
                save_session_to_file(session)?;
            }
        }
    }

    let new_id = Uuid::new_v4().to_string();
    let new_session = ChatSession::new(new_id.clone(), "New Chat".to_string());
    sessions.insert(new_id.clone(), new_session);
    *current_id_guard = Some(new_id.clone());

    Ok(new_id)
}

#[tauri::command]
async fn select_session(
    id_to_select: String,
    state: State<'_, Arc<AppState>>,
) -> Result<ChatSession, String> {
    let mut sessions = state.sessions.lock().unwrap();
    let mut current_id_guard = state.current_session_id.lock().unwrap();

    if let Some(old_id) = current_id_guard.clone() {
        if old_id != id_to_select {
            let is_empty = sessions
                .get(&old_id)
                .map_or(true, |s| s.messages.is_empty());

            if is_empty {
                sessions.remove(&old_id);
            } else {
                if let Some(old_session) = sessions.get_mut(&old_id) {
                    if old_session.title == "New Chat" {
                        old_session.title = generate_session_title(&old_session.messages);
                    }
                    old_session.updated_at = now_ts();
                    save_session_to_file(old_session)?;
                }
            }
        }
    }

    if let Some(new_session) = sessions.get(&id_to_select) {
        *current_id_guard = Some(id_to_select);
        Ok(new_session.clone())
    } else {
        Err("Session to select not found".to_string())
    }
}

/// Reads the last `n` lines from a file.
/// This is useful for reading the tail of a log file.
fn read_last_lines_of_file(path: &std::path::Path, n: usize) -> Result<String, std::io::Error> {
    use std::io::{BufRead, BufReader};
    let file = File::open(path)?;
    let reader = BufReader::new(file);
    let lines: Vec<String> = reader.lines().collect::<Result<Vec<_>, _>>()?;
    
    if lines.is_empty() {
        return Ok(String::new());
    }
    
    let start = if lines.len() > n { lines.len() - n } else { 0 };
    Ok(lines[start..].join("
"))
}

fn setup_logging() {
    let log_dir = get_app_log_dir();
    let file_appender = tracing_appender::rolling::daily(log_dir, "app.log");
    let (non_blocking, _guard) = tracing_appender::non_blocking(file_appender);

    use tracing_subscriber::fmt::format::FmtSpan;
    use tracing_subscriber::{EnvFilter, FmtSubscriber};

    let subscriber = FmtSubscriber::builder()
        .with_max_level(tracing::Level::INFO)
        .with_env_filter(EnvFilter::from_default_env().add_directive("info".parse().unwrap()))
        .with_writer(non_blocking)
        .with_ansi(false) // Disable ANSI colors in log files
        .with_span_events(FmtSpan::CLOSE)
        .finish();

    tracing::subscriber::set_global_default(subscriber)
        .expect("Failed to set global default subscriber");

    // We need to keep the guard alive for the duration of the program.
    // In a Tauri app, we can leak it.
    std::mem::forget(_guard);
    info!("Logging initialized.");
}

fn setup_app(app: &mut App) -> Result<(), Box<dyn std::error::Error>> {
    let app_state = app.state::<Arc<AppState>>();
    let config = app_state.config.lock().unwrap().clone();
    let server_names: Vec<String> = config.mcp_servers.keys().cloned().collect();
    let window = app.get_window("main").unwrap();

    info!(
        "App setup: Found {} MCP servers in config.",
        server_names.len()
    );

    for name in server_names {
        let state_clone = app_state.inner().clone();
        let window_clone = window.clone();
        tauri::async_runtime::spawn(async move {
            if let Err(e) = _start_mcp_server_logic(name.clone(), state_clone, window_clone.clone()).await {
                error!(server_name = %name, "Failed to auto-start MCP server: {}", e);
                let msg = format!("The MCP server '{}' failed to start.\n\nError: {}", name, e);
                tauri::api::dialog::message(Some(&window_clone), "MCP Server Error", msg);
            }
        });
    }

    Ok(())
}

fn main() {
    setup_logging();
    let config = load_or_initialize_config();
    let sessions = load_sessions_from_files();

    let app_state = Arc::new(AppState {
        config: Mutex::new(config),
        sessions: Mutex::new(sessions),
        current_session_id: Mutex::new(None),
        tool_states: Mutex::new(HashMap::new()),
        mcp_tools: Mutex::new(HashMap::new()),
        mcp_clients: Mutex::new(HashMap::new()),
    });

    tauri::Builder::default()
        .manage(app_state)
        .setup(setup_app)
        .invoke_handler(tauri::generate_handler![
            // MCP
            get_mcp_servers,
            start_mcp_server,
            stop_mcp_server,
            get_discovered_tools,
            // Agent
            run_agent_task,
            // Session
            get_all_sessions,
            finalize_and_new_chat,
            select_session,
            open_config_file,
            rename_session,
            delete_session
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
